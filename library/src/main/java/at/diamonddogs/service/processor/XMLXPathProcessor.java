/*
 * Copyright (C) 2013 the diamond:dogs|group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package at.diamonddogs.service.processor;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;

import at.diamonddogs.exception.ProcessorExeception;

/**
 * This subclass if {@link XMLProcessor} can be used if one wants to use
 * {@link XPath} to parse XML.
 * 
 * @param <OUTPUT>
 *            the type of output {@link Object} generated by this
 *            {@link XMLXPathProcessor}
 */
public abstract class XMLXPathProcessor<OUTPUT> extends XMLProcessor<OUTPUT> {

	/**
	 * The {@link XPathFactory} used by this processor, can be modified by
	 * overriding {@link XMLXPathProcessor#initializeXPathFactory()}
	 */
	private XPathFactory xPathFactory;

	/**
	 * Creates an instance of XMLProcessor using a predefined
	 * {@link DocumentBuilderFactory}
	 */
	public XMLXPathProcessor() {
		super();
		initializeXPathFactory();
	}

	/**
	 * Creates an instance of XMLProcessor using a custom
	 * {@link DocumentBuilderFactory}
	 * 
	 * @param factory
	 */
	public XMLXPathProcessor(DocumentBuilderFactory factory) {
		super(factory);
		initializeXPathFactory();
	}

	/**
	 * Creates an instance of {@link XPathFactory} to be used to obtain a new
	 * instance of {@link XPath}. Override this method in order to change the
	 * factory initialization process.
	 */
	protected void initializeXPathFactory() {
		xPathFactory = XPathFactory.newInstance();
	}

	/**
	 * Returns a new instance of {@link XPath} using the factory created by
	 * {@link XMLXPathProcessor#initializeXPathFactory()}
	 * 
	 * @return a new instance of {@link XPath}
	 */
	protected XPath newXPath() {
		return xPathFactory.newXPath();
	}

	/**
	 * Compiles an {@link XPathExpression} using the provided {@link XPath}
	 * using {@link XPath#compile(String)} and {@link String} expression. All
	 * possible {@link Throwable}s are caught and
	 * wrapped in a {@link ProcessorExeception}.
	 * 
	 * @param xPath
	 *            the {@link XPath} object to use
	 * @param expression
	 *            the {@link String} expression to compile
	 * @return an instance of {@link XPathExpression}
	 * @throws ProcessorExeception
	 *             when a {@link Throwable} is caught
	 */
	protected XPathExpression compileXPathExpression(XPath xPath, String expression) {
		try {
			return xPath.compile(expression);
		} catch (Throwable tr) {
			throw new ProcessorExeception(tr);
		}
	}

	protected XPathExpression compileXPathExpression(String expression) {
		return compileXPathExpression(newXPath(), expression);
	}

	/**
	 * A wrapper for {@link XPath#evaluate(String, InputSource)}, all
	 * {@link Throwable}s are caught and wrapped in a
	 * {@link ProcessorExeception}
	 * 
	 * @param xPath
	 *            an instance of {@link XPath} to use
	 * @param expression
	 *            a {@link String} expression
	 * @param source
	 *            an {@link InputSource}
	 * @return the result {@link String}
	 */
	protected String evaluateXPathExpression(XPath xPath, String expression, InputSource source) {
		try {
			return xPath.evaluate(expression, source);
		} catch (Throwable tr) {
			throw new ProcessorExeception(tr);
		}
	}

	/**
	 * Does the same as
	 * {@link XMLXPathProcessor#evaluateXPathExpression(XPath, String, InputSource)}
	 * but creates a new {@link XPath} (used a single time)
	 * 
	 * @param expression
	 *            a {@link String} expression
	 * @param source
	 *            an {@link InputSource}
	 * @return
	 */
	protected String evaluateXPathExpression(String expression, InputSource source) {
		return evaluateXPathExpression(newXPath(), expression, source);
	}

	/**
	 * A wrapper for {@link XPath#evaluate(String, Object)}, all
	 * {@link Throwable}s are caught and wrapped in a
	 * {@link ProcessorExeception}
	 * 
	 * @param xPath
	 *            an instance of {@link XPath} to use
	 * @param expression
	 *            a {@link String} expression
	 * @param item
	 *            a starting context e.g. a {@link Node} or {@link NodeList}
	 * @return the result {@link String}
	 */
	protected String evaluateXPathExpression(XPath xPath, String expression, Object item) {
		try {
			return xPath.evaluate(expression, item);
		} catch (Throwable tr) {
			throw new ProcessorExeception(tr);
		}
	}

	/**
	 * Does the same as
	 * {@link XMLXPathProcessor#evaluateXPathExpression(XPath, String, Object)}
	 * but creates a new {@link XPath} (used a single time)
	 * 
	 * @param expression
	 *            a {@link String} expression
	 * @param item
	 *            a starting context e.g. a {@link Node} or {@link NodeList}
	 * @return the result {@link String}
	 */
	protected String evaluateXPathExpression(String expression, Object item) {
		return evaluateXPathExpression(newXPath(), expression, item);
	}

	/**
	 * A wrapper for {@link XPath#evaluate(String, InputSource, QName)}, all
	 * {@link Throwable}s are caught and wrapped in a
	 * {@link ProcessorExeception}
	 * 
	 * @param xPath
	 *            an instance of {@link XPath} to use
	 * @param expression
	 *            a {@link String} expression
	 * @param source
	 *            an {@link InputSource}
	 * @param returnType
	 *            the return type
	 * @return an {@link Object} of the provided returnType
	 */
	protected Object evaluateXPathExpression(XPath xPath, String expression, InputSource source, QName returnType) {
		try {
			return xPath.evaluate(expression, source, returnType);
		} catch (Throwable tr) {
			throw new ProcessorExeception(tr);
		}
	}

	/**
	 * Does the same as
	 * {@link XMLXPathProcessor#evaluateXPathExpression(XPath, String, InputSource, QName)}
	 * but creates a new {@link XPath} (used a single time)
	 * 
	 * @param expression
	 *            a {@link String} expression
	 * @param source
	 *            an {@link InputSource}
	 * @param returnType
	 *            the return type
	 * @return an {@link Object} of the provided returnType
	 */
	protected Object evaluateXPathExpression(String expression, InputSource source, QName returnType) {
		return evaluateXPathExpression(newXPath(), expression, source, returnType);
	}

	/**
	 * A wrapper for {@link XPath#evaluate(String, InputSource, QName)}, all
	 * {@link Throwable}s are caught and wrapped in a
	 * {@link ProcessorExeception}
	 * 
	 * @param xPath
	 *            an instance of {@link XPath} to use
	 * @param expression
	 *            a {@link String} expression
	 * @param item
	 *            a starting context e.g. a {@link Node} or {@link NodeList}
	 * @param returnType
	 *            the return type
	 * @return an {@link Object} of the provided returnType
	 */
	protected Object evaluateXPathExpression(XPath xPath, String expression, Object item, QName returnType) {
		try {
			return xPath.evaluate(expression, item, returnType);
		} catch (Throwable tr) {
			throw new ProcessorExeception(tr);
		}
	}

	/**
	 * Does the same as
	 * {@link XMLXPathProcessor#evaluateXPathExpression(XPath, String, Object, QName)}
	 * but creates a new {@link XPath} (used a single time)
	 * 
	 * @param expression
	 *            a {@link String} expression
	 * @param item
	 *            a starting context e.g. a {@link Node} or {@link NodeList}
	 * @param returnType
	 *            the return type
	 * @return an {@link Object} of the provided returnType
	 */
	protected Object evaluateXPathExpression(String expression, Object item, QName returnType) {
		return evaluateXPathExpression(newXPath(), expression, item, returnType);
	}
}